---
id: 'auth-mfa-webauthn'
title: 'Multi-Factor Authentication (WebAuthn)'
description: 'Add an additional layer of security with passwordless authentication using biometrics and security keys.'
---

## What is WebAuthn?

WebAuthn (Web Authentication) is a web standard that enables secure, passwordless authentication using public-key cryptography. It allows users to log in to websites and applications using built-in authenticators like fingerprint sensors, facial recognition, or external devices like security keys.

### When to Use WebAuthn?

Consider implementing WebAuthn when:

1. You want to enhance security beyond traditional passwords
2. You aim to provide a more user-friendly authentication experience
3. You need to reduce costs associated with SMS-based authentication
4. You want to offer a hardware backup to existing authentication factors

WebAuthn is particularly suitable for security-conscious applications that require a user-friendly, passwordless solution.

### Pricing and Availability

WebAuthn MFA is part of the Auth Advanced MFA Add-on. Here's the breakdown of pricing:

- Cost: $75 per month for the first project in the organization
- Additional projects: $10 per month each
- Included in the Add-on: Phone and other advanced MFA features

### Brower Support

- Link to the caniuse specification

## Types of Authenticators

An authenticator is a component that securely generates and stores cryptographic keys associated with a particular relying \***\*party (web page origin) and a credential \*\***ID (a unique identifier for the key). The authenticator uses these keys to authenticate the user to the relying party without directly storing user-specific data like the user ID.

There are two main types of authenticators:

1. **Platform Authenticators**: Built into the user's device
   - Examples:
     - Desktop: Touch ID (macOS), Windows Hello (Windows)
     - Mobile: Face ID (iOS), Biometrics (Android)
2. **Roaming Authenticators**: Portable devices that work across multiple platforms
   - Examples: YubiKey, Google Titan Security Key, Solokeys

## Authentication Flows

WebAuthn involves two primary processes: Enrollment and Login. Both follow a similar pattern:

<Image
  alt="Diagram showing the flow of Multi-Factor authentication"
  src={{
    light: '/docs/img/guides/auth-mfa/auth-mfa-webauthn-flow.svg',
    dark: '/docs/img/guides/auth-mfa/auth-mfa-webauthn-flow.svg',
  }}
  containerClassName="max-w-[700px]"
/>

### Step-by-Step Explanation

1. The user's device initiates the process by requesting a challenge from the server.
2. The server generates and sends a unique challenge to the authenticator.
3. The authenticator prompts the user for verification.
4. The user provides the required verification (e.g., fingerprint, face scan).
5. Upon successful user verification, the authenticator signs the challenge using its private key.
6. The server validates the signed challenge using the corresponding public key.
7. If the validation is successful, the authentication process is completed.

This flow applies to both enrollment (when setting up WebAuthn) and login (when using WebAuthn to authenticate).

**Navigator API**

In both flows, WebAuthn interacts with the browser through the Navigator API, specifically using the `navigator.credentials` interface. This API provides methods like `create()` for registering new credentials and `get()` for authenticating existing ones. By handling the secure communication with authenticators (such as hardware tokens or biometrics), the Navigator API simplifies the implementation of WebAuthn, allowing developers to focus on integrating strong, passwordless authentication into their web applications.

### Add enrollment flow

An enrollment flow provides a UI for users to set up additional authentication factors. Most applications add the enrollment flow in two places within their app:

1. Right after login or sign up.
   This allows users quickly set up Multi Factor Authentication (MFA) post login or account creation. Where possible, encourage all users to set up MFA. Many applications offer this as an opt-in step in an
   effort to reduce onboarding friction.
2. From within a settings page.
   Allows users to set up, disable or modify their MFA settings.

As far as possible, maintain a generic flow that you can reuse in both cases with minor modifications.

You can enroll a WebAuthn factor with a single step:

```ts
import { browserSupportsWebAuthn } from '@supabase/supabase-js'
if (supabase.auth.browserSupportsWebAuthn()) {
    const { data, error } = await supabase.auth.mfa.enroll({ factorType: 'webauthn'})
}) else {
   // Use another MFA method, such as MFA (Phone)
   // const { data, error } = await supabase.auth.mfa.enroll({ factorType: 'phone', phone: '<your-phone-number>' })
};
```

Or in multiple-steps by setting the `useMultiStepEnroll` parameter to true.

```ts
const { data: { factorId }, error } = await supabase.auth.mfa.enroll({ factorType: 'webauthn', useMultiStep: true })

const { data: {options}, error } = await supabase.auth.mfa.challenge({ factorId })
const options = await supabase.auth.generateRegistrationOptions{
		options,
		rp_name,
		user: {
			name,
			display_name,
		}
		authenticator_options: {
			attestation: 'direct', // or developer choice of 'enterprise'
			authenticatorAttachment,
			requireResidentKey,
			userVerification,
		}
	}
})

const credential = await navigator.credentials.create(data)
const { data, error } = await supabase.auth.mfa.verify({ factorId, credential })
```

`useMultiStep` informs Auth to abstract away the complexities of interacting with the browser API. Multi Step enrollment is recommended only for Advanced Users who require more customization in their application

When using multi-step enroll there are a substantial number of fields to deal with. The fields are highlighted below:

| Field Type       | Field Name                | Configurability                                                                                      | Description                                                           |
| ---------------- | ------------------------- | ---------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------- |
| Configurable     | `attestation`             | Developer choice                                                                                     | Type of attestation requested (e.g., 'direct', 'indirect', 'none')    |
| Configurable     | `authenticatorAttachment` | Developer choice                                                                                     | Preferred authenticator type ('platform' or 'cross-platform')         |
| Configurable     | `requireResidentKey`      | Developer choice                                                                                     | Whether a resident key is required (true or false)                    |
| Configurable     | `userVerification`        | Developer choice                                                                                     | User verification preference ('required', 'preferred', 'discouraged') |
| Configurable     | `rp.name`                 | Developer choice                                                                                     | Human-readable name for the Relying Party                             |

While configurable fields can be set by developers, it's important to choose appropriate values based on your security requirements and user experience considerations.

Visit the MDN Documentation for a full description of each field [here](https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredentialCreationOptions)

## Add Login Flow

Once a user has registered a factor, they can proceed to log in. In single-step mode this is accomplished with:

```ts
const { data, error } = await supabase.auth.mfa.verify({ factorType: 'webauthn' })
```

As with enrollment, developers have the option of performing verification over multiple steps.

```ts
const { data: factors, error } = await supabase.auth.mfa.listFactors()
const { data, error } = await supabase.auth.mfa.challenge({
	factorId: factors.find((type) => type === 'webauthn'), // use first verified factor
	})

const credential = await generateAuthenticationOptions({authenticator: {userVerification, timeout, authenticatorAttachment}})

const { data: factor, error } = await supabase.auth.mfa.verify({ factorId, credential, useMultiStep: true})
```

Note that you do not have to specify a `factorId` parameter. Unlike MFA (Phone) and MFA (TOTP), authentication via the WebAuthn factor does not depend on the specific factor in use. Auth will check the assertion against all verified factors owned by the user, as well as the existing WebAuthn session, and make a decision on authentication based on the information given.

### Selecting between multiple factor types

Build an intermediary page to allow users to select between factor types:

// Add factor selection page

## Factor Management

Use the WebAuthn AAGUID to identify the type of authenticator used (e.g. Chrome Profile on Mac, Yubikey). There is a [community sourced JSON](https://github.com/passkeydeveloper/passkey-authenticator-aaguids) mapping from AAGUID to passkey name.

```ts
import aaguids from './aaguids.json' with { type: 'json' };

const { data, error } = await supabase.auth.mfa.listFactors()

const provider_name = aaguids[data.webauthn.webauthn_aaguid]?.name || 'Unknown';
```

You can confirm that the mapping is accurate by using the helper site [on this page](https://passkeydeveloper.github.io/passkey-authenticator-aaguids/explorer/?combined)

### MFA Enforcement

Enforcement remains the same

### Factor Unenrollment

Remains the same

## Error Handling and Timeouts

- Default timeout is five seconds
- We do not detect compromised hardware factors. Please periodically check against the attestation service. You can do so by:
<include section>


## Local Development

You will need to configure the following fields in `config.toml` to enable MFA for WebAuthn.





## Frequently Asked Questions

### Are Passkeys Supported?

For the moment, we do not support Passkeys as a Sign In or Sign Up method. Please check back in the future



- Attestation Service -> Not currently enabled
- `getClaims` method
